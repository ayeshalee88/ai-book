"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[367],{15680:(e,n,t)=>{t.d(n,{xA:()=>m,yg:()=>d});var a=t(96540);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach(function(n){i(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function r(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},m=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},g=a.forwardRef(function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,m=r(e,["components","mdxType","originalType","parentName"]),p=c(t),g=i,d=p["".concat(s,".").concat(g)]||p[g]||u[g]||o;return t?a.createElement(d,l(l({ref:n},m),{},{components:t})):a.createElement(d,l({ref:n},m))});function d(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,l=new Array(o);l[0]=g;var r={};for(var s in n)hasOwnProperty.call(n,s)&&(r[s]=n[s]);r.originalType=e,r[p]="string"==typeof e?e:i,l[1]=r;for(var c=2;c<o;c++)l[c]=t[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}g.displayName="MDXCreateElement"},81648:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>f,contentTitle:()=>y,default:()=>k,frontMatter:()=>d,metadata:()=>h,toc:()=>v});var a=t(58168),i=t(96540),o=t(15680);const l="visualizerContainer_TOTJ",r="controls_iRqa",s="sliderContainer_dMZ6",c="canvasContainer_AoJM",m="robotCanvas_cBU_",p="infoPanel_J7jq",u="fallbackContent_mopc",g=({robotModel:e="simple_arm",jointAngles:n=[0,0],targetPosition:t=null,showWorkspace:a=!0,interactive:o=!0})=>{const g=(0,i.useRef)(null),[d,y]=(0,i.useState)(n),[h,f]=(0,i.useState)(!1),[v,b]=(0,i.useState)(null),N=200,k=350,_=100,x=80,M=e=>{const[n,t]=e,a=N+_*Math.cos(n),i=k-_*Math.sin(n);return{x1:a,y1:i,x2:a+x*Math.cos(n+t),y2:i-x*Math.sin(n+t)}},P=(e,n)=>{const t=e-N,a=k-n,i=Math.sqrt(t*t+a*a);if(i>180){return[Math.atan2(a,t),0]}if(i<Math.abs(20))return[0,0];{const e=(i*i-1e4-6400)/16e3,n=Math.acos(Math.max(-1,Math.min(1,e))),o=_+x*Math.cos(n),l=x*Math.sin(n);return[Math.atan2(a,t)-Math.atan2(l,o),n]}},C=()=>{f(!1)};return(0,i.useEffect)(()=>{const e=g.current;if(e){(e=>{if(!e)return;e.clearRect(0,0,400,400),a&&(e.beginPath(),e.arc(N,k,180,0,2*Math.PI),e.strokeStyle="rgba(200, 200, 200, 0.3)",e.stroke(),e.beginPath(),e.arc(N,k,Math.abs(20),0,2*Math.PI),e.strokeStyle="rgba(200, 200, 200, 0.3)",e.stroke());const{x1:n,y1:i,x2:o,y2:l}=M(d);e.beginPath(),e.arc(N,k,10,0,2*Math.PI),e.fillStyle="#333",e.fill(),e.beginPath(),e.moveTo(N,k),e.lineTo(n,i),e.lineWidth=8,e.strokeStyle="#2e8555",e.stroke(),e.beginPath(),e.arc(n,i,6,0,2*Math.PI),e.fillStyle="#333",e.fill(),e.beginPath(),e.moveTo(n,i),e.lineTo(o,l),e.lineWidth=6,e.strokeStyle="#2e8555",e.stroke(),e.beginPath(),e.arc(o,l,8,0,2*Math.PI),e.fillStyle="#d95757",e.fill(),t&&(e.beginPath(),e.arc(t[0],t[1],10,0,2*Math.PI),e.strokeStyle="#d95757",e.lineWidth=2,e.stroke(),e.beginPath(),e.arc(t[0],t[1],3,0,2*Math.PI),e.fillStyle="#d95757",e.fill()),e.beginPath(),e.arc(o,l,5,0,2*Math.PI),e.fillStyle="#57a0d9",e.fill()})(e.getContext("2d"))}},[d,t,a]),(0,i.useEffect)(()=>{y(n)},[n]),i.createElement("div",{className:l,role:"region","aria-labelledby":"visualizer-title"},i.createElement("h3",{id:"visualizer-title"},"Robot Kinematics Visualizer"),i.createElement("p",null,"2-DOF Planar Robot Arm Visualization"),i.createElement("noscript",null,i.createElement("div",{className:u},i.createElement("h4",null,"Interactive Visualization Disabled"),i.createElement("p",null,"To see the interactive robot kinematics visualization, please enable JavaScript."),i.createElement("p",null,"In the meantime, here's a description of the 2-DOF robot arm:"),i.createElement("ul",null,i.createElement("li",null,"Base position: Center-bottom of visualization area"),i.createElement("li",null,"Link 1: 100 units long, connected to base"),i.createElement("li",null,"Link 2: 80 units long, connected to end of Link 1"),i.createElement("li",null,"Forward kinematics: Calculates end-effector position from joint angles"),i.createElement("li",null,"Inverse kinematics: Calculates joint angles from end-effector position")))),i.createElement("div",{className:r,role:"group","aria-label":"Robot arm controls"},i.createElement("div",{className:s},i.createElement("label",{htmlFor:"joint1-slider"},"Joint 1: ",(180*d[0]/Math.PI).toFixed(1),"\xb0"),i.createElement("input",{id:"joint1-slider",type:"range",min:-Math.PI,max:Math.PI,step:.01,value:d[0],onChange:e=>y([parseFloat(e.target.value),d[1]]),disabled:!o,"aria-valuemin":-Math.PI,"aria-valuemax":Math.PI,"aria-valuenow":d[0],"aria-valuetext":`Joint 1 angle: ${(180*d[0]/Math.PI).toFixed(1)} degrees`})),i.createElement("div",{className:s},i.createElement("label",{htmlFor:"joint2-slider"},"Joint 2: ",(180*d[1]/Math.PI).toFixed(1),"\xb0"),i.createElement("input",{id:"joint2-slider",type:"range",min:-Math.PI,max:Math.PI,step:.01,value:d[1],onChange:e=>y([d[0],parseFloat(e.target.value)]),disabled:!o,"aria-valuemin":-Math.PI,"aria-valuemax":Math.PI,"aria-valuenow":d[1],"aria-valuetext":`Joint 2 angle: ${(180*d[1]/Math.PI).toFixed(1)} degrees`}))),i.createElement("div",{className:c,role:"img","aria-label":"Robot arm visualization"},i.createElement("canvas",{ref:g,width:400,height:400,onMouseDown:e=>{if(!o)return;const n=g.current.getBoundingClientRect(),t=e.clientX-n.left,a=e.clientY-n.top;f(!0),b([t,a]);const i=P(t,a);y(i)},onMouseMove:e=>{if(!h||!o)return;const n=g.current.getBoundingClientRect(),t=e.clientX-n.left,a=e.clientY-n.top;b([t,a]);const i=P(t,a);y(i)},onMouseUp:C,onMouseLeave:C,className:m,"aria-hidden":"true"})),i.createElement("div",{className:p,role:"status","aria-live":"polite"},i.createElement("h4",null,"Current Position"),i.createElement("p",null,"End Effector: (",M(d).x2.toFixed(1),", ",M(d).y2.toFixed(1),")"),i.createElement("p",null,"Joint Angles: [",(180*d[0]/Math.PI).toFixed(1),"\xb0, ",(180*d[1]/Math.PI).toFixed(1),"\xb0]")))},d={id:"kinematics",title:"Kinematics in Humanoid Robotics",sidebar_label:"Kinematics"},y="Kinematics in Humanoid Robotics",h={unversionedId:"humanoid-robotics/kinematics",id:"humanoid-robotics/kinematics",title:"Kinematics in Humanoid Robotics",description:"Introduction to Robot Kinematics",source:"@site/docs/humanoid-robotics/kinematics.md",sourceDirName:"humanoid-robotics",slug:"/humanoid-robotics/kinematics",permalink:"/ai-book/docs/humanoid-robotics/kinematics",draft:!1,editUrl:"https://github.com/ayeshalee88/ai-book/edit/main/docusaurus-book/docs/humanoid-robotics/kinematics.md",tags:[],version:"current",frontMatter:{id:"kinematics",title:"Kinematics in Humanoid Robotics",sidebar_label:"Kinematics"},sidebar:"tutorialSidebar",previous:{title:"Design Principles",permalink:"/ai-book/docs/humanoid-robotics/design-principles"},next:{title:"Control Systems",permalink:"/ai-book/docs/humanoid-robotics/control-systems"}},f={},v=[{value:"Introduction to Robot Kinematics",id:"introduction-to-robot-kinematics",level:2},{value:"Key Concepts in Robot Kinematics",id:"key-concepts-in-robot-kinematics",level:3},{value:"Degrees of Freedom (DOF)",id:"degrees-of-freedom-dof",level:4},{value:"Joint Types",id:"joint-types",level:4},{value:"Forward Kinematics",id:"forward-kinematics",level:3},{value:"Mathematical Representation",id:"mathematical-representation",level:4},{value:"Denavit-Hartenberg (DH) Convention",id:"denavit-hartenberg-dh-convention",level:4},{value:"Example: 2-DOF Planar Arm",id:"example-2-dof-planar-arm",level:4},{value:"Inverse Kinematics",id:"inverse-kinematics",level:3},{value:"Analytical Solutions",id:"analytical-solutions",level:4},{value:"Numerical Methods",id:"numerical-methods",level:4},{value:"Kinematics for Humanoid Systems",id:"kinematics-for-humanoid-systems",level:3},{value:"Bipedal Locomotion Kinematics",id:"bipedal-locomotion-kinematics",level:4},{value:"Center of Mass (CoM) Control",id:"center-of-mass-com-control",level:4},{value:"Whole-Body Kinematics",id:"whole-body-kinematics",level:4},{value:"Kinematic Constraints and Limitations",id:"kinematic-constraints-and-limitations",level:3},{value:"Joint Limits",id:"joint-limits",level:4},{value:"Workspace Analysis",id:"workspace-analysis",level:4},{value:"Singularities",id:"singularities",level:4},{value:"Practical Implementation Considerations",id:"practical-implementation-considerations",level:3},{value:"Computational Efficiency",id:"computational-efficiency",level:4},{value:"Numerical Stability",id:"numerical-stability",level:4},{value:"Integration with Dynamics",id:"integration-with-dynamics",level:4},{value:"Advanced Topics",id:"advanced-topics",level:3},{value:"Redundant Manipulation",id:"redundant-manipulation",level:4},{value:"Kinematic Calibration",id:"kinematic-calibration",level:4},{value:"Learning Objectives",id:"learning-objectives",level:3},{value:"Hands-On Exercise",id:"hands-on-exercise",level:3},{value:"Related Topics",id:"related-topics",level:3},{value:"Interactive Kinematics Visualization",id:"interactive-kinematics-visualization",level:2},{value:"Next Steps",id:"next-steps",level:2}],b={toc:v},N="wrapper";function k({components:e,...n}){return(0,o.yg)(N,(0,a.A)({},b,n,{components:e,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"kinematics-in-humanoid-robotics"},"Kinematics in Humanoid Robotics"),(0,o.yg)("h2",{id:"introduction-to-robot-kinematics"},"Introduction to Robot Kinematics"),(0,o.yg)("p",null,"Kinematics is the study of motion without considering the forces that cause it. In humanoid robotics, kinematics provides the mathematical foundation for describing and controlling the robot's movements. Understanding kinematics is crucial for tasks such as walking, reaching, manipulation, and maintaining balance."),(0,o.yg)("h3",{id:"key-concepts-in-robot-kinematics"},"Key Concepts in Robot Kinematics"),(0,o.yg)("h4",{id:"degrees-of-freedom-dof"},"Degrees of Freedom (DOF)"),(0,o.yg)("p",null,"The number of independent parameters that define the configuration of a mechanical system. For humanoid robots:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Spatial Motion"),": 6 DOF (3 translational, 3 rotational) for position and orientation"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Planar Motion"),": 3 DOF (2 translational, 1 rotational) for 2D movement"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Joint DOF"),": Each joint contributes 1-3 DOF depending on joint type")),(0,o.yg)("h4",{id:"joint-types"},"Joint Types"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Revolute Joint"),": 1 DOF rotation around an axis"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Prismatic Joint"),": 1 DOF linear motion along an axis"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Spherical Joint"),": 3 DOF rotation (like human ball-and-socket joints)"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Cylindrical Joint"),": 2 DOF (rotation + translation along same axis)")),(0,o.yg)("h3",{id:"forward-kinematics"},"Forward Kinematics"),(0,o.yg)("p",null,"Forward kinematics calculates the end-effector position and orientation given joint angles. This is essential for understanding where robot limbs are positioned in space."),(0,o.yg)("h4",{id:"mathematical-representation"},"Mathematical Representation"),(0,o.yg)("p",null,"The pose (position and orientation) of each link in a robot chain is represented using homogeneous transformation matrices:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"T = [R  p]\n    [0  1]\n")),(0,o.yg)("p",null,"Where R is a 3\xd73 rotation matrix and p is a 3\xd71 position vector."),(0,o.yg)("p",null,"For a chain of n joints:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"T_total = T_0_1 * T_1_2 * ... * T_(n-1)_n\n")),(0,o.yg)("h4",{id:"denavit-hartenberg-dh-convention"},"Denavit-Hartenberg (DH) Convention"),(0,o.yg)("p",null,"The DH convention provides a systematic method for defining coordinate frames on robot links:"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("strong",{parentName:"li"},"z_i axis"),": Along the axis of actuation of joint i+1"),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("strong",{parentName:"li"},"x_i axis"),": Along the common normal from z",(0,o.yg)("em",{parentName:"li"},"i to z"),"(i+1)"),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("strong",{parentName:"li"},"y_i axis"),": Completes the right-handed coordinate system")),(0,o.yg)("p",null,"DH parameters:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"a_i"),": Distance along x",(0,o.yg)("em",{parentName:"li"},"i from z_i to z"),"(i+1)"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"\u03b1_i"),": Angle about x",(0,o.yg)("em",{parentName:"li"},"i from z_i to z"),"(i+1)"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"d_i"),": Distance along z",(0,o.yg)("em",{parentName:"li"},"i from x"),"(i-1) to x_i"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"\u03b8_i"),": Angle about z",(0,o.yg)("em",{parentName:"li"},"i from x"),"(i-1) to x_i")),(0,o.yg)("h4",{id:"example-2-dof-planar-arm"},"Example: 2-DOF Planar Arm"),(0,o.yg)("p",null,"Consider a simple 2-DOF planar arm with link lengths L1 and L2:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},'import numpy as np\n\ndef forward_kinematics_2dof(joint_angles, link_lengths):\n    """\n    Calculate end-effector position for 2-DOF planar arm\n    joint_angles: [theta1, theta2] in radians\n    link_lengths: [L1, L2]\n    """\n    theta1, theta2 = joint_angles\n    L1, L2 = link_lengths\n\n    # Calculate end-effector position\n    x = L1 * np.cos(theta1) + L2 * np.cos(theta1 + theta2)\n    y = L1 * np.sin(theta1) + L2 * np.sin(theta1 + theta2)\n\n    return np.array([x, y])\n\n# Example usage\njoint_angles = [np.pi/4, np.pi/6]  # 45\xb0 and 30\xb0\nlink_lengths = [1.0, 0.8]  # 1m and 0.8m\nend_pos = forward_kinematics_2dof(joint_angles, link_lengths)\nprint(f"End-effector position: {end_pos}")\n')),(0,o.yg)("h3",{id:"inverse-kinematics"},"Inverse Kinematics"),(0,o.yg)("p",null,"Inverse kinematics (IK) solves the reverse problem: given a desired end-effector position and orientation, find the joint angles required to achieve it."),(0,o.yg)("h4",{id:"analytical-solutions"},"Analytical Solutions"),(0,o.yg)("p",null,"For simple robot structures, closed-form solutions exist:"),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"2-DOF Planar Arm Inverse Kinematics:")),(0,o.yg)("p",null,"Given desired end-effector position (x, y) and link lengths L1, L2:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},'def inverse_kinematics_2dof(end_pos, link_lengths):\n    """\n    Calculate joint angles for 2-DOF planar arm\n    end_pos: [x, y] desired end-effector position\n    link_lengths: [L1, L2]\n    """\n    x, y = end_pos\n    L1, L2 = link_lengths\n\n    # Calculate distance from base to end-effector\n    r = np.sqrt(x**2 + y**2)\n\n    # Check if position is reachable\n    if r > L1 + L2:\n        raise ValueError("Position is outside workspace")\n    if r < abs(L1 - L2):\n        raise ValueError("Position is inside workspace but unreachable")\n\n    # Calculate joint angles\n    cos_theta2 = (r**2 - L1**2 - L2**2) / (2 * L1 * L2)\n    theta2 = np.arccos(cos_theta2)\n\n    k1 = L1 + L2 * np.cos(theta2)\n    k2 = L2 * np.sin(theta2)\n\n    theta1 = np.arctan2(y, x) - np.arctan2(k2, k1)\n\n    return np.array([theta1, theta2])\n')),(0,o.yg)("h4",{id:"numerical-methods"},"Numerical Methods"),(0,o.yg)("p",null,"For complex robots, numerical methods are often used:"),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Jacobian-Based Methods:")),(0,o.yg)("p",null,"The Jacobian matrix relates joint velocities to end-effector velocities:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"v = J(\u03b8) * \u03b8\u0307\n")),(0,o.yg)("p",null,"Where:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"v is the end-effector velocity vector"),(0,o.yg)("li",{parentName:"ul"},"J(\u03b8) is the Jacobian matrix"),(0,o.yg)("li",{parentName:"ul"},"\u03b8\u0307 is the joint velocity vector")),(0,o.yg)("p",null,"For inverse kinematics:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"\u03b8\u0307 = J^(-1) * v\n")),(0,o.yg)("p",null,"However, the Jacobian may be singular (non-invertible), requiring techniques like:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Pseudoinverse"),": \u03b8\u0307 = J^T ",(0,o.yg)("em",{parentName:"li"}," (J ")," J^T)^(-1) * v"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Damped Least Squares"),": \u03b8\u0307 = J^T ",(0,o.yg)("em",{parentName:"li"}," (J ")," J^T + \u03bb\xb2I)^(-1) * v")),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},'def jacobian_2dof(joint_angles, link_lengths):\n    """\n    Calculate Jacobian for 2-DOF planar arm\n    """\n    theta1, theta2 = joint_angles\n    L1, L2 = link_lengths\n\n    # Calculate Jacobian matrix\n    J = np.array([\n        [-L1*np.sin(theta1) - L2*np.sin(theta1+theta2), -L2*np.sin(theta1+theta2)],\n        [L1*np.cos(theta1) + L2*np.cos(theta1+theta2), L2*np.cos(theta1+theta2)]\n    ])\n\n    return J\n\ndef ik_jacobian_inverse(end_pos_desired, current_angles, link_lengths,\n                       step_size=0.01, max_iterations=1000, tolerance=1e-6):\n    """\n    Solve inverse kinematics using Jacobian inverse method\n    """\n    current_angles = np.array(current_angles)\n\n    for i in range(max_iterations):\n        # Calculate current end-effector position\n        current_pos = forward_kinematics_2dof(current_angles, link_lengths)\n\n        # Calculate error\n        error = end_pos_desired - current_pos\n\n        if np.linalg.norm(error) < tolerance:\n            break\n\n        # Calculate Jacobian\n        J = jacobian_2dof(current_angles, link_lengths)\n\n        # Calculate joint angle adjustment\n        try:\n            # Use pseudoinverse to handle near-singularities\n            J_inv = np.linalg.pinv(J)\n            angle_adjustment = J_inv @ error * step_size\n        except:\n            # If pseudoinverse fails, use transpose method\n            J_inv = J.T @ np.linalg.inv(J @ J.T + 1e-6 * np.eye(2))\n            angle_adjustment = J_inv @ error * step_size\n\n        # Update joint angles\n        current_angles += angle_adjustment\n\n    return current_angles\n')),(0,o.yg)("h3",{id:"kinematics-for-humanoid-systems"},"Kinematics for Humanoid Systems"),(0,o.yg)("h4",{id:"bipedal-locomotion-kinematics"},"Bipedal Locomotion Kinematics"),(0,o.yg)("p",null,"Humanoid walking involves complex kinematic patterns:"),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Stride Parameters:")),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Step Length"),": Distance between consecutive foot placements"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Step Width"),": Lateral distance between feet"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Stride Length"),": Distance between consecutive placements of the same foot"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Cadence"),": Steps per minute")),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Gait Cycle Phases:")),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("strong",{parentName:"li"},"Double Support"),": Both feet on ground (typically 20% of cycle)"),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("strong",{parentName:"li"},"Single Support"),": One foot on ground (typically 80% of cycle)"),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("strong",{parentName:"li"},"Swing Phase"),": Foot in air moving forward")),(0,o.yg)("h4",{id:"center-of-mass-com-control"},"Center of Mass (CoM) Control"),(0,o.yg)("p",null,"For stable bipedal locomotion, the CoM trajectory must be carefully controlled:"),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Zero Moment Point (ZMP):"),"\nThe ZMP is the point on the ground where the net moment of the ground reaction forces is zero. For stability, the ZMP must remain within the support polygon (area of ground contact)."),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Linear Inverted Pendulum Model (LIPM):"),"\nA simplified model for CoM motion:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"\u1e8d = g/h * (x - z)\n")),(0,o.yg)("p",null,"Where:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"x is CoM position"),(0,o.yg)("li",{parentName:"ul"},"z is ZMP position"),(0,o.yg)("li",{parentName:"ul"},"h is CoM height"),(0,o.yg)("li",{parentName:"ul"},"g is gravitational acceleration")),(0,o.yg)("h4",{id:"whole-body-kinematics"},"Whole-Body Kinematics"),(0,o.yg)("p",null,"Humanoid robots often have 20+ degrees of freedom, requiring coordinated control:"),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Task-Space Control:")),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Multiple end-effectors (hands, feet, head) controlled simultaneously"),(0,o.yg)("li",{parentName:"ul"},"Coordination of upper and lower body movements"),(0,o.yg)("li",{parentName:"ul"},"Balance maintenance during manipulation")),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Redundancy Resolution:"),"\nWith more DOF than minimally required for tasks:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Null-space optimization for secondary objectives"),(0,o.yg)("li",{parentName:"ul"},"Joint limit avoidance"),(0,o.yg)("li",{parentName:"ul"},"Singularity avoidance"),(0,o.yg)("li",{parentName:"ul"},"Energy minimization")),(0,o.yg)("h3",{id:"kinematic-constraints-and-limitations"},"Kinematic Constraints and Limitations"),(0,o.yg)("h4",{id:"joint-limits"},"Joint Limits"),(0,o.yg)("p",null,"Physical constraints on joint angles affect workspace and motion planning:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Hard Limits"),": Mechanical stops preventing damage"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Soft Limits"),": Recommended operating ranges for safety/comfort"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Dynamic Limits"),": Speed and acceleration constraints")),(0,o.yg)("h4",{id:"workspace-analysis"},"Workspace Analysis"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Dexterous Workspace"),": Positions/orientations reachable with full DOF"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Reachable Workspace"),": Positions reachable with any orientation"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Orientation Workspace"),": Orientations achievable at fixed position")),(0,o.yg)("h4",{id:"singularities"},"Singularities"),(0,o.yg)("p",null,"Configurations where the robot loses one or more DOF:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Boundary Singularities"),": At workspace limits"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Interior Singularities"),": Within workspace (e.g., fully extended arm)"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Wrist Singularities"),": When multiple joint axes align")),(0,o.yg)("h3",{id:"practical-implementation-considerations"},"Practical Implementation Considerations"),(0,o.yg)("h4",{id:"computational-efficiency"},"Computational Efficiency"),(0,o.yg)("p",null,"For real-time control:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Analytical Solutions"),": When available, preferred for speed"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Pre-computed Lookups"),": For frequently used poses"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Approximation Methods"),": When exact solutions are too slow")),(0,o.yg)("h4",{id:"numerical-stability"},"Numerical Stability"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Singular Value Decomposition (SVD)"),": For robust matrix inversion"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Regularization"),": Adding small values to prevent division by zero"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Convergence Criteria"),": Proper termination conditions")),(0,o.yg)("h4",{id:"integration-with-dynamics"},"Integration with Dynamics"),(0,o.yg)("p",null,"Kinematic solutions must consider dynamic constraints:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Joint Torque Limits"),": Achievable motions within actuator capabilities"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Inertia Effects"),": Motion planning considering robot mass distribution"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Contact Forces"),": Maintaining balance during interaction")),(0,o.yg)("h3",{id:"advanced-topics"},"Advanced Topics"),(0,o.yg)("h4",{id:"redundant-manipulation"},"Redundant Manipulation"),(0,o.yg)("p",null,"Using extra DOF for optimization:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Null-Space Motion"),": Joint motion that doesn't affect end-effector"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Task Prioritization"),": Multiple tasks with different priorities"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Obstacle Avoidance"),": Using redundancy for collision avoidance")),(0,o.yg)("h4",{id:"kinematic-calibration"},"Kinematic Calibration"),(0,o.yg)("p",null,"Improving kinematic accuracy through measurement:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Parameter Identification"),": Determining actual DH parameters"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Vision-Based Calibration"),": Using cameras to measure poses"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Self-Calibration"),": Using internal sensors for parameter estimation")),(0,o.yg)("h3",{id:"learning-objectives"},"Learning Objectives"),(0,o.yg)("p",null,"After studying this chapter, you should be able to:"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},"Calculate forward kinematics for simple robot mechanisms"),(0,o.yg)("li",{parentName:"ol"},"Solve inverse kinematics using analytical and numerical methods"),(0,o.yg)("li",{parentName:"ol"},"Apply kinematic principles to humanoid robot systems"),(0,o.yg)("li",{parentName:"ol"},"Understand the relationship between kinematics and balance control"),(0,o.yg)("li",{parentName:"ol"},"Implement basic kinematic algorithms for robot control"),(0,o.yg)("li",{parentName:"ol"},"Analyze workspace and singularity properties of robot mechanisms")),(0,o.yg)("h3",{id:"hands-on-exercise"},"Hands-On Exercise"),(0,o.yg)("p",null,"Implement a kinematic solver for a simple humanoid arm with 7 DOF:"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},"Define the kinematic structure using DH parameters"),(0,o.yg)("li",{parentName:"ol"},"Implement forward kinematics function"),(0,o.yg)("li",{parentName:"ol"},"Implement inverse kinematics using Jacobian-based methods"),(0,o.yg)("li",{parentName:"ol"},"Test with various end-effector positions"),(0,o.yg)("li",{parentName:"ol"},"Analyze workspace and singularity properties")),(0,o.yg)("h3",{id:"related-topics"},"Related Topics"),(0,o.yg)("p",null,"For deeper exploration of concepts covered in this chapter, see:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"../embodied-ai/introduction"},"Fundamentals of Physical AI")," - Core principles of embodied AI"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"../embodied-ai/sensorimotor-loops"},"Sensorimotor Loops in Embodied Systems")," - Understanding sensorimotor coupling"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"./control-systems"},"Control Systems for Humanoid Robots")," - Control theory applied to robotic systems"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"../ai-integration/ml-locomotion"},"Machine Learning for Locomotion")," - ML approaches to kinematic control"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"../challenges-ethics/safety-considerations"},"Safety Considerations in Physical AI Systems")," - Safety aspects in kinematic control")),(0,o.yg)("h2",{id:"interactive-kinematics-visualization"},"Interactive Kinematics Visualization"),(0,o.yg)("p",null,"Try out the kinematics concepts with our interactive robot arm visualizer:"),(0,o.yg)(g,{jointAngles:[.5,.3],showWorkspace:!0,interactive:!0,mdxType:"RobotKinematicsVisualizer"}),(0,o.yg)("h2",{id:"next-steps"},"Next Steps"),(0,o.yg)("p",null,(0,o.yg)("a",{parentName:"p",href:"./control-systems"},"Next: Control Systems for Humanoid Robots")),(0,o.yg)("p",null,"This exercise will help you understand the practical challenges of kinematic control in humanoid robots."))}k.isMDXComponent=!0}}]);