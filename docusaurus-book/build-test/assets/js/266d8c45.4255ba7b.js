"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[779],{15680:(e,n,t)=>{t.d(n,{xA:()=>c,yg:()=>p});var o=t(96540);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,o)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach(function(n){a(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function s(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=o.createContext({}),m=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=m(e.components);return o.createElement(l.Provider,{value:n},e.children)},d="mdxType",_={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},f=o.forwardRef(function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=m(t),f=a,p=d["".concat(l,".").concat(f)]||d[f]||_[f]||r;return t?o.createElement(p,i(i({ref:n},c),{},{components:t})):o.createElement(p,i({ref:n},c))});function p(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,i=new Array(r);i[0]=f;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[d]="string"==typeof e?e:a,i[1]=s;for(var m=2;m<r;m++)i[m]=t[m];return o.createElement.apply(null,i)}return o.createElement.apply(null,t)}f.displayName="MDXCreateElement"},70815:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>_,frontMatter:()=>r,metadata:()=>s,toc:()=>m});var o=t(58168),a=(t(96540),t(15680));const r={id:"hardware-integration",title:"Hardware Integration for Physical AI Systems",sidebar_label:"Hardware Integration"},i="Hardware Integration for Physical AI Systems",s={unversionedId:"tutorials/hardware-integration",id:"tutorials/hardware-integration",title:"Hardware Integration for Physical AI Systems",description:"Introduction to Hardware Integration",source:"@site/docs/tutorials/hardware-integration.md",sourceDirName:"tutorials",slug:"/tutorials/hardware-integration",permalink:"/ai-book/docs/tutorials/hardware-integration",draft:!1,editUrl:"https://github.com/ayeshalee88/ai-book/edit/main/docusaurus-book/docs/tutorials/hardware-integration.md",tags:[],version:"current",frontMatter:{id:"hardware-integration",title:"Hardware Integration for Physical AI Systems",sidebar_label:"Hardware Integration"},sidebar:"tutorialSidebar",previous:{title:"Simulation Environments",permalink:"/ai-book/docs/tutorials/simulation-environments"},next:{title:"Safety Considerations",permalink:"/ai-book/docs/challenges-ethics/safety-considerations"}},l={},m=[{value:"Introduction to Hardware Integration",id:"introduction-to-hardware-integration",level:2},{value:"Key Challenges in Hardware Integration",id:"key-challenges-in-hardware-integration",level:3},{value:"Mechanical Integration",id:"mechanical-integration",level:2},{value:"Design for Assembly and Maintenance",id:"design-for-assembly-and-maintenance",level:3},{value:"Material Selection and Properties",id:"material-selection-and-properties",level:3},{value:"Electrical Integration",id:"electrical-integration",level:2},{value:"Power Distribution and Management",id:"power-distribution-and-management",level:3},{value:"Communication Protocols and Interfaces",id:"communication-protocols-and-interfaces",level:3},{value:"Sensor Integration",id:"sensor-integration",level:2},{value:"IMU Integration and Calibration",id:"imu-integration-and-calibration",level:3},{value:"Camera Integration",id:"camera-integration",level:3},{value:"Actuator Integration",id:"actuator-integration",level:2},{value:"Servo Motor Control",id:"servo-motor-control",level:3},{value:"Motor Control with Feedback",id:"motor-control-with-feedback",level:3},{value:"Software Integration",id:"software-integration",level:2},{value:"Real-time Control Considerations",id:"real-time-control-considerations",level:3},{value:"Safety and Fault Handling",id:"safety-and-fault-handling",level:2},{value:"Safety System Implementation",id:"safety-system-implementation",level:3},{value:"Troubleshooting and Debugging",id:"troubleshooting-and-debugging",level:2},{value:"Common Hardware Integration Issues",id:"common-hardware-integration-issues",level:3},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Hands-On Exercise",id:"hands-on-exercise",level:2}],c={toc:m},d="wrapper";function _({components:e,...n}){return(0,a.yg)(d,(0,o.A)({},c,n,{components:e,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"hardware-integration-for-physical-ai-systems"},"Hardware Integration for Physical AI Systems"),(0,a.yg)("h2",{id:"introduction-to-hardware-integration"},"Introduction to Hardware Integration"),(0,a.yg)("p",null,"Hardware integration is a critical aspect of physical AI systems, requiring careful consideration of mechanical design, electronics, sensors, actuators, and software interfaces. This tutorial covers the practical aspects of integrating various hardware components into functional robotic systems."),(0,a.yg)("h3",{id:"key-challenges-in-hardware-integration"},"Key Challenges in Hardware Integration"),(0,a.yg)("p",null,"Hardware integration for physical AI systems presents several unique challenges:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Mechanical Integration"),": Ensuring components fit together and function as intended"),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Electrical Integration"),": Managing power distribution, signal integrity, and communication"),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Software Integration"),": Creating interfaces between hardware and control algorithms"),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Real-time Performance"),": Meeting timing constraints for responsive behavior"),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Safety Considerations"),": Ensuring safe operation around humans and environments"),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Reliability"),": Maintaining consistent performance over extended operation")),(0,a.yg)("h2",{id:"mechanical-integration"},"Mechanical Integration"),(0,a.yg)("h3",{id:"design-for-assembly-and-maintenance"},"Design for Assembly and Maintenance"),(0,a.yg)("p",null,"When designing mechanical systems, consider assembly and maintenance requirements:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},"# Example: Modular robot design with standardized interfaces\nclass ModularRobotDesign:\n    \"\"\"\n    A framework for designing modular robots with standardized interfaces\n    \"\"\"\n    def __init__(self):\n        self.modules = []\n        self.interfaces = []\n        self.connection_points = []\n\n    def add_module(self, module_type, position, orientation):\n        \"\"\"\n        Add a module (e.g., actuator, sensor, link) at specified position\n        \"\"\"\n        module = {\n            'type': module_type,\n            'position': position,\n            'orientation': orientation,\n            'connections': [],\n            'mass': self.get_module_mass(module_type),\n            'inertia': self.get_module_inertia(module_type)\n        }\n        self.modules.append(module)\n        return module\n\n    def add_standardized_interface(self, module1, module2, interface_type='bolt_pattern'):\n        \"\"\"\n        Add a standardized interface between two modules\n        \"\"\"\n        interface = {\n            'module1': module1,\n            'module2': module2,\n            'type': interface_type,\n            'specification': self.get_interface_spec(interface_type),\n            'strength': self.calculate_connection_strength(interface_type)\n        }\n        self.interfaces.append(interface)\n        return interface\n\n    def get_module_mass(self, module_type):\n        \"\"\"Get typical mass for module type\"\"\"\n        mass_table = {\n            'servo_motor': 0.1,  # kg\n            'dc_motor': 0.5,\n            'imu_sensor': 0.05,\n            'camera': 0.2,\n            'link_aluminum': 0.3,\n            'link_carbon_fiber': 0.1\n        }\n        return mass_table.get(module_type, 0.1)\n\n    def get_module_inertia(self, module_type):\n        \"\"\"Get typical inertia for module type\"\"\"\n        # Simplified - in reality this would be 3x3 tensor\n        inertia_table = {\n            'servo_motor': [0.001, 0.001, 0.002],\n            'dc_motor': [0.01, 0.01, 0.02],\n            'imu_sensor': [0.0001, 0.0001, 0.0001],\n            'camera': [0.001, 0.002, 0.001],\n            'link_aluminum': [0.01, 0.01, 0.001],\n            'link_carbon_fiber': [0.005, 0.005, 0.0005]\n        }\n        return inertia_table.get(module_type, [0.001, 0.001, 0.001])\n\n    def calculate_connection_strength(self, interface_type):\n        \"\"\"Calculate load capacity of connection interface\"\"\"\n        strength_table = {\n            'bolt_pattern': 500,  # N\n            'quick_disconnect': 200,\n            'snap_fit': 50,\n            'screw_mount': 100\n        }\n        return strength_table.get(interface_type, 100)\n\n    def check_mechanical_feasibility(self):\n        \"\"\"\n        Check if the mechanical design is feasible\n        \"\"\"\n        total_mass = sum(module['mass'] for module in self.modules)\n        connection_loads = self.calculate_connection_loads()\n\n        # Check if connections can handle loads\n        for interface in self.interfaces:\n            if connection_loads[interface['type']] > interface['strength']:\n                return False, f\"Connection {interface['type']} exceeds strength limits\"\n\n        return True, f\"Design is mechanically feasible (total mass: {total_mass:.2f} kg)\"\n\n    def calculate_connection_loads(self):\n        \"\"\"Calculate expected loads on connections\"\"\"\n        # Simplified load calculation\n        return {'bolt_pattern': 300, 'quick_disconnect': 150}\n\n# Example usage\nrobot_design = ModularRobotDesign()\ntorso = robot_design.add_module('link_carbon_fiber', [0, 0, 0], [0, 0, 0])\nhead = robot_design.add_module('camera', [0, 0, 0.1], [0, 0, 0])\nrobot_design.add_standardized_interface(torso, head, 'bolt_pattern')\n\nis_feasible, message = robot_design.check_mechanical_feasibility()\nprint(message)\n")),(0,a.yg)("h3",{id:"material-selection-and-properties"},"Material Selection and Properties"),(0,a.yg)("p",null,"Material selection significantly impacts robot performance:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},"class MaterialSelector:\n    \"\"\"\n    Select appropriate materials based on requirements\n    \"\"\"\n    def __init__(self):\n        self.material_properties = {\n            'aluminum_6061': {\n                'density': 2700,  # kg/m\xb3\n                'young_modulus': 69e9,  # Pa\n                'yield_strength': 276e6,  # Pa\n                'cost': 2.5,  # $/kg\n                'machinability': 'good',\n                'corrosion_resistance': 'good'\n            },\n            'carbon_fiber': {\n                'density': 1700,\n                'young_modulus': 230e9,\n                'yield_strength': 1000e6,\n                'cost': 50.0,\n                'machinability': 'poor',\n                'corrosion_resistance': 'excellent'\n            },\n            'steel_4140': {\n                'density': 7850,\n                'young_modulus': 200e9,\n                'yield_strength': 415e6,\n                'cost': 5.0,\n                'machinability': 'good',\n                'corrosion_resistance': 'poor'\n            },\n            'plastic_abs': {\n                'density': 1040,\n                'young_modulus': 2.5e9,\n                'yield_strength': 40e6,\n                'cost': 3.0,\n                'machinability': 'excellent',\n                'corrosion_resistance': 'good'\n            }\n        }\n\n    def select_material(self, requirements):\n        \"\"\"\n        Select material based on requirements\n\n        requirements: dict with keys like 'max_weight', 'min_strength', 'max_cost'\n        \"\"\"\n        candidates = []\n\n        for material, props in self.material_properties.items():\n            if (requirements.get('max_density', float('inf')) >= props['density'] and\n                requirements.get('min_strength', 0) <= props['yield_strength'] and\n                requirements.get('max_cost', float('inf')) >= props['cost']):\n\n                # Calculate score based on requirements\n                score = 0\n                if 'weight_priority' in requirements:\n                    score += (1 / props['density']) * requirements.get('weight_priority', 1)\n                if 'strength_priority' in requirements:\n                    score += (props['yield_strength'] / 1e6) * requirements.get('strength_priority', 1)\n\n                candidates.append((material, score))\n\n        # Return highest scoring material\n        if candidates:\n            return max(candidates, key=lambda x: x[1])[0]\n        else:\n            return None\n\n# Example usage\nselector = MaterialSelector()\nrequirements = {\n    'max_density': 3000,\n    'min_strength': 200e6,\n    'max_cost': 20.0,\n    'weight_priority': 2,\n    'strength_priority': 1\n}\nmaterial = selector.select_material(requirements)\nprint(f\"Recommended material: {material}\")\n")),(0,a.yg)("h2",{id:"electrical-integration"},"Electrical Integration"),(0,a.yg)("h3",{id:"power-distribution-and-management"},"Power Distribution and Management"),(0,a.yg)("p",null,"Proper power distribution is critical for reliable operation:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'class PowerDistributionSystem:\n    """\n    Design and analyze power distribution for robot\n    """\n    def __init__(self, battery_voltage=24.0, battery_capacity=50.0):  # V, Ah\n        self.battery_voltage = battery_voltage\n        self.battery_capacity = battery_capacity\n        self.components = []\n        self.wiring = []\n\n    def add_component(self, name, voltage, current_draw, duty_cycle=1.0):\n        """\n        Add electrical component to the system\n        """\n        component = {\n            \'name\': name,\n            \'voltage\': voltage,  # V\n            \'current_draw\': current_draw,  # A\n            \'duty_cycle\': duty_cycle,  # Fraction of time active\n            \'power_draw\': voltage * current_draw * duty_cycle,  # W\n            \'power_supply\': self.select_power_supply(voltage)\n        }\n        self.components.append(component)\n        return component\n\n    def select_power_supply(self, required_voltage):\n        """Select appropriate power supply method"""\n        if required_voltage == self.battery_voltage:\n            return "direct_battery"\n        elif required_voltage < self.battery_voltage:\n            return "buck_converter"\n        else:\n            return "boost_converter"\n\n    def calculate_total_power_consumption(self):\n        """Calculate total power consumption"""\n        total_power = sum(comp[\'power_draw\'] for comp in self.components)\n        return total_power\n\n    def calculate_battery_life(self):\n        """Calculate estimated battery life"""\n        total_current = 0\n        for comp in self.components:\n            total_current += comp[\'current_draw\'] * comp[\'duty_cycle\']\n\n        battery_life_hours = (self.battery_capacity * self.battery_voltage) / \\\n                            (self.calculate_total_power_consumption())\n        return battery_life_hours\n\n    def design_wiring_harness(self):\n        """Design wiring harness based on power requirements"""\n        wiring_harness = []\n\n        # Group components by voltage requirements\n        voltage_groups = {}\n        for comp in self.components:\n            voltage = comp[\'voltage\']\n            if voltage not in voltage_groups:\n                voltage_groups[voltage] = []\n            voltage_groups[voltage].append(comp)\n\n        # Design wire gauge for each group\n        for voltage, components in voltage_groups.items():\n            total_current = sum(comp[\'current_draw\'] * comp[\'duty_cycle\'] for comp in components)\n\n            # Calculate required wire gauge (simplified)\n            # Using rule of thumb: 1 mm\xb2 per 10A for safety\n            required_area = max(0.5, total_current / 10.0)  # mm\xb2\n            wire_gauge = self.area_to_awg(required_area)\n\n            harness = {\n                \'voltage\': voltage,\n                \'components\': [comp[\'name\'] for comp in components],\n                \'wire_gauge\': wire_gauge,\n                \'current_rating\': total_current\n            }\n            wiring_harness.append(harness)\n\n        return wiring_harness\n\n    def area_to_awg(self, area_mm2):\n        """Convert wire cross-sectional area to AWG gauge"""\n        # Simplified conversion\n        awg_lookup = {\n            0.05: 24, 0.08: 22, 0.13: 20, 0.20: 18,\n            0.32: 16, 0.51: 14, 0.81: 12, 1.31: 10,\n            2.08: 8, 3.31: 6, 5.26: 4, 8.37: 2\n        }\n\n        for area, awg in sorted(awg_lookup.items(), reverse=True):\n            if area_mm2 >= area:\n                return awg\n        return 24  # Default to smallest wire\n\n    def check_power_budget(self):\n        """Verify power consumption is within battery limits"""\n        total_power = self.calculate_total_power_consumption()\n        max_available_power = self.battery_voltage * (self.battery_capacity / 1)  # 1 hour discharge\n\n        if total_power > max_available_power:\n            return False, f"Power consumption ({total_power:.1f}W) exceeds available power ({max_available_power:.1f}W)"\n        else:\n            return True, f"Power budget OK (available: {max_available_power:.1f}W, consuming: {total_power:.1f}W)"\n\n# Example: Design power system for a small robot\npower_system = PowerDistributionSystem(battery_voltage=24.0, battery_capacity=20.0)\n\n# Add components\npower_system.add_component("main_controller", 5.0, 2.0, 1.0)\npower_system.add_component("motors", 24.0, 10.0, 0.3)  # 30% duty cycle\npower_system.add_component("sensors", 12.0, 1.0, 1.0)\npower_system.add_component("communication", 5.0, 0.5, 1.0)\n\n# Check power budget\nis_ok, message = power_system.check_power_budget()\nprint(message)\n\n# Design wiring harness\nwiring = power_system.design_wiring_harness()\nfor harness in wiring:\n    print(f"Voltage {harness[\'voltage\']}V: {harness[\'wire_gauge\']} AWG wire for {harness[\'components\']}")\n\n# Calculate battery life\nbattery_life = power_system.calculate_battery_life()\nprint(f"Estimated battery life: {battery_life:.2f} hours")\n')),(0,a.yg)("h3",{id:"communication-protocols-and-interfaces"},"Communication Protocols and Interfaces"),(0,a.yg)("p",null,"Robots typically use multiple communication protocols:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},"class CommunicationSystem:\n    \"\"\"\n    Design communication system for robot\n    \"\"\"\n    def __init__(self):\n        self.interfaces = []\n        self.protocols = {\n            'i2c': {'max_devices': 128, 'speed': 400000, 'distance': 1},  # bps, meters\n            'spi': {'max_devices': 1, 'speed': 10000000, 'distance': 0.5},\n            'uart': {'max_devices': 2, 'speed': 115200, 'distance': 15},\n            'can': {'max_devices': 110, 'speed': 1000000, 'distance': 40},\n            'ethernet': {'max_devices': 1000, 'speed': 100000000, 'distance': 100}\n        }\n\n    def add_interface(self, protocol, device_count, data_rate, distance):\n        \"\"\"\n        Add communication interface\n        \"\"\"\n        if protocol not in self.protocols:\n            raise ValueError(f\"Unknown protocol: {protocol}\")\n\n        spec = self.protocols[protocol]\n\n        if device_count > spec['max_devices']:\n            raise ValueError(f\"Too many devices for {protocol} (max: {spec['max_devices']})\")\n\n        if data_rate > spec['speed']:\n            raise ValueError(f\"Data rate too high for {protocol} (max: {spec['speed']} bps)\")\n\n        if distance > spec['distance']:\n            raise ValueError(f\"Distance too long for {protocol} (max: {spec['distance']} m)\")\n\n        interface = {\n            'protocol': protocol,\n            'device_count': device_count,\n            'data_rate': data_rate,\n            'distance': distance,\n            'spec': spec\n        }\n        self.interfaces.append(interface)\n        return interface\n\n    def optimize_communication_topology(self):\n        \"\"\"\n        Optimize communication based on requirements\n        \"\"\"\n        # Group devices by communication needs\n        high_speed_devices = []\n        medium_speed_devices = []\n        low_speed_devices = []\n\n        for interface in self.interfaces:\n            if interface['data_rate'] > 1000000:  # > 1 Mbps\n                high_speed_devices.append(interface)\n            elif interface['data_rate'] > 100000:  # > 100 kbps\n                medium_speed_devices.append(interface)\n            else:\n                low_speed_devices.append(interface)\n\n        # Assign protocols based on needs\n        topology = {\n            'high_speed': 'ethernet' if high_speed_devices else None,\n            'medium_speed': 'spi' if medium_speed_devices else 'uart',\n            'low_speed': 'i2c' if low_speed_devices else 'can'\n        }\n\n        return topology\n\n    def generate_device_addressing_scheme(self):\n        \"\"\"\n        Generate addressing scheme for devices\n        \"\"\"\n        addressing_scheme = {}\n\n        # For I2C devices\n        i2c_devices = [iface for iface in self.interfaces if iface['protocol'] == 'i2c']\n        if i2c_devices:\n            # Typical I2C addresses (simplified)\n            base_address = 0x40\n            for i in range(i2c_devices[0]['device_count']):\n                addressing_scheme[f\"i2c_device_{i}\"] = hex(base_address + i)\n\n        # For CAN devices\n        can_devices = [iface for iface in self.interfaces if iface['protocol'] == 'can']\n        if can_devices:\n            for i in range(can_devices[0]['device_count']):\n                addressing_scheme[f\"can_node_{i}\"] = i + 1  # CAN uses node IDs 1-110\n\n        return addressing_scheme\n\n# Example: Design communication for a sensor-laden robot\ncomm_system = CommunicationSystem()\n\n# Add various interfaces\ncomm_system.add_interface('i2c', 5, 100000, 0.5)  # IMU, pressure sensors\ncomm_system.add_interface('spi', 1, 5000000, 0.2)  # High-speed ADC\ncomm_system.add_interface('uart', 2, 115200, 2.0)  # GPS, XBee\ncomm_system.add_interface('can', 8, 500000, 10.0)  # Motor controllers\n\n# Optimize topology\ntopology = comm_system.optimize_communication_topology()\nprint(\"Communication topology:\", topology)\n\n# Generate addressing\naddressing = comm_system.generate_device_addressing_scheme()\nprint(\"Device addressing:\", addressing)\n")),(0,a.yg)("h2",{id:"sensor-integration"},"Sensor Integration"),(0,a.yg)("h3",{id:"imu-integration-and-calibration"},"IMU Integration and Calibration"),(0,a.yg)("p",null,"Inertial Measurement Units (IMUs) are crucial for balance and orientation:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'import numpy as np\nfrom scipy.spatial.transform import Rotation as R\n\nclass IMUIntegrator:\n    """\n    Integrate IMU data for orientation estimation\n    """\n    def __init__(self, sample_rate=100):\n        self.sample_rate = sample_rate\n        self.dt = 1.0 / sample_rate\n        self.orientation = R.from_quat([0, 0, 0, 1])  # Initial orientation (identity)\n        self.gyro_bias = np.zeros(3)  # Gyro bias\n        self.accel_bias = np.zeros(3)  # Accelerometer bias\n        self.calibration_samples = []\n\n    def calibrate_sensor(self, accel_data, gyro_data, num_samples=1000):\n        """\n        Calibrate IMU by collecting samples in static position\n        """\n        print("Starting IMU calibration...")\n\n        # Collect calibration samples\n        for i in range(num_samples):\n            # In real implementation, read from sensor\n            # For simulation, we\'ll use the provided data\n            if i < len(accel_data) and i < len(gyro_data):\n                self.calibration_samples.append({\n                    \'accel\': accel_data[i],\n                    \'gyro\': gyro_data[i]\n                })\n\n        # Calculate biases (assuming robot is stationary)\n        avg_accel = np.mean([s[\'accel\'] for s in self.calibration_samples], axis=0)\n        avg_gyro = np.mean([s[\'gyro\'] for s in self.calibration_samples], axis=0)\n\n        # Accelerometer should read [0, 0, 9.81] when level\n        self.accel_bias = avg_accel - np.array([0, 0, 9.81])\n        self.gyro_bias = avg_gyro  # Gyro should read [0, 0, 0] when stationary\n\n        print(f"Calibration complete. Accel bias: {self.accel_bias}, Gyro bias: {self.gyro_bias}")\n\n    def update_orientation(self, raw_accel, raw_gyro):\n        """\n        Update orientation estimate using accelerometer and gyroscope\n        """\n        # Apply calibration\n        accel = np.array(raw_accel) - self.accel_bias\n        gyro = np.array(raw_gyro) - self.gyro_bias\n\n        # Normalize accelerometer (for gravity reference)\n        accel_norm = accel / np.linalg.norm(accel)\n\n        # Integrate gyroscope for orientation change\n        angle_change = gyro * self.dt\n        rotation_vector = R.from_rotvec(angle_change)\n\n        # Update orientation\n        self.orientation = self.orientation * rotation_vector\n\n        # Use accelerometer to correct drift (simplified gravity alignment)\n        current_gravity = self.orientation.apply([0, 0, 1])  # Robot\'s perceived gravity\n        gravity_error = accel_norm - current_gravity\n\n        # Apply correction (simple proportional control)\n        correction_gain = 0.01\n        correction_vector = np.cross(current_gravity, accel_norm)\n        correction_rotation = R.from_rotvec(correction_gain * correction_vector)\n        self.orientation = correction_rotation * self.orientation\n\n        return self.orientation.as_quat()\n\n    def get_euler_angles(self):\n        """Get orientation as Euler angles (roll, pitch, yaw)"""\n        return self.orientation.as_euler(\'xyz\', degrees=True)\n\nclass MultiIMUManager:\n    """\n    Manage multiple IMUs for redundancy and accuracy\n    """\n    def __init__(self, num_imus=3):\n        self.imus = [IMUIntegrator() for _ in range(num_imus)]\n        self.weights = np.ones(num_imus) / num_imus  # Equal weights initially\n        self.fault_detection_threshold = 0.1\n\n    def calibrate_all_imus(self, accel_data, gyro_data):\n        """Calibrate all IMUs"""\n        for imu in self.imus:\n            imu.calibrate_sensor(accel_data, gyro_data)\n\n    def update_all_imus(self, all_accel_data, all_gyro_data):\n        """\n        Update all IMUs and combine readings with fault detection\n        """\n        orientations = []\n\n        for i, (accel, gyro) in enumerate(zip(all_accel_data, all_gyro_data)):\n            quat = self.imus[i].update_orientation(accel, gyro)\n            orientations.append(np.array(quat))\n\n        # Detect potential sensor faults by comparing readings\n        self.detect_and_handle_faults(orientations)\n\n        # Weighted average of orientations\n        weighted_quat = np.average(orientations, axis=0, weights=self.weights)\n        # Normalize the quaternion\n        weighted_quat = weighted_quat / np.linalg.norm(weighted_quat)\n\n        return weighted_quat\n\n    def detect_and_handle_faults(self, orientations):\n        """\n        Detect sensor faults and adjust weights accordingly\n        """\n        if len(orientations) < 2:\n            return\n\n        # Calculate differences between all IMU readings\n        for i in range(len(orientations)):\n            total_diff = 0\n            for j in range(len(orientations)):\n                if i != j:\n                    # Calculate angular difference between quaternions\n                    q1, q2 = orientations[i], orientations[j]\n                    # Convert to rotation vectors for comparison\n                    r1 = R.from_quat(q1).as_rotvec()\n                    r2 = R.from_quat(q2).as_rotvec()\n                    diff = np.linalg.norm(r1 - r2)\n                    total_diff += diff\n\n            # If difference is too large, reduce weight\n            avg_diff = total_diff / (len(orientations) - 1)\n            if avg_diff > self.fault_detection_threshold:\n                self.weights[i] *= 0.5  # Reduce weight of potentially faulty sensor\n                print(f"Potential fault detected on IMU {i}, reducing weight")\n            else:\n                # Gradually restore weight if consistent\n                self.weights[i] = min(1.0, self.weights[i] * 1.01)\n\n# Example usage\nimu_manager = MultiIMUManager(num_imus=3)\n\n# Simulated calibration data (robot stationary)\ncalib_accel = [[0.1, -0.05, 9.85] for _ in range(100)]\ncalib_gyro = [[0.01, -0.02, 0.005] for _ in range(100)]\n\nimu_manager.calibrate_all_imus(calib_accel, calib_gyro)\n\n# Simulated real-time data\nreal_accel = [[0.05, 0.1, 9.7], [0.08, -0.02, 9.82], [0.04, 0.05, 9.78]]\nreal_gyro = [[0.1, 0.05, -0.02], [0.12, 0.04, -0.01], [0.09, 0.06, -0.03]]\n\ncombined_orientation = imu_manager.update_all_imus(real_accel, real_gyro)\nprint(f"Combined orientation: {combined_orientation}")\n')),(0,a.yg)("h3",{id:"camera-integration"},"Camera Integration"),(0,a.yg)("p",null,"Camera systems require careful integration for computer vision applications:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'import cv2\nimport numpy as np\n\nclass CameraSystem:\n    """\n    Integrate and manage camera systems\n    """\n    def __init__(self, camera_id=0):\n        self.camera_id = camera_id\n        self.cap = None\n        self.camera_matrix = None\n        self.dist_coeffs = None\n        self.resolution = (640, 480)\n        self.fps = 30\n\n    def initialize_camera(self):\n        """Initialize camera with settings"""\n        self.cap = cv2.VideoCapture(self.camera_id)\n\n        if not self.cap.isOpened():\n            raise RuntimeError(f"Cannot open camera {self.camera_id}")\n\n        # Set resolution and FPS\n        self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, self.resolution[0])\n        self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, self.resolution[1])\n        self.cap.set(cv2.CAP_PROP_FPS, self.fps)\n\n        print(f"Camera initialized: {self.resolution[0]}x{self.resolution[1]} @ {self.fps} FPS")\n\n    def calibrate_camera(self, calibration_images):\n        """\n        Calibrate camera using checkerboard images\n        """\n        # Prepare object points (3D points in real world)\n        objp = np.zeros((6*9, 3), np.float32)\n        objp[:, :2] = np.mgrid[0:9, 0:6].T.reshape(-1, 2)\n\n        objpoints = []  # 3D points in real world\n        imgpoints = []  # 2D points in image\n\n        for img in calibration_images:\n            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n            # Find chessboard corners\n            ret, corners = cv2.findChessboardCorners(gray, (9, 6), None)\n\n            if ret:\n                objpoints.append(objp)\n                imgpoints.append(corners)\n\n        if len(objpoints) > 0:\n            ret, self.camera_matrix, self.dist_coeffs, rvecs, tvecs = \\\n                cv2.calibrateCamera(objpoints, imgpoints, gray.shape[::-1], None, None)\n\n            print(f"Camera calibration successful: {ret}")\n            print(f"Camera matrix:\\n{self.camera_matrix}")\n            print(f"Distortion coefficients: {self.dist_coeffs.flatten()}")\n        else:\n            print("Camera calibration failed - no valid images found")\n\n    def get_frame(self):\n        """Get a frame from the camera"""\n        if self.cap is None:\n            self.initialize_camera()\n\n        ret, frame = self.cap.read()\n        if not ret:\n            raise RuntimeError("Failed to read frame from camera")\n\n        return frame\n\n    def undistort_image(self, img):\n        """Remove lens distortion from image"""\n        if self.camera_matrix is not None and self.dist_coeffs is not None:\n            h, w = img.shape[:2]\n            new_camera_matrix, roi = cv2.getOptimalNewCameraMatrix(\n                self.camera_matrix, self.dist_coeffs, (w, h), 1, (w, h)\n            )\n\n            undistorted = cv2.undistort(img, self.camera_matrix, self.dist_coeffs, None, new_camera_matrix)\n\n            # Crop image based on ROI\n            x, y, w, h = roi\n            undistorted = undistorted[y:y+h, x:x+w]\n            return undistorted\n        else:\n            return img  # Return original if not calibrated\n\n    def get_camera_parameters(self):\n        """Get camera intrinsic parameters"""\n        return {\n            \'camera_matrix\': self.camera_matrix,\n            \'distortion_coefficients\': self.dist_coeffs,\n            \'resolution\': self.resolution,\n            \'focal_length\': self.camera_matrix[0, 0] if self.camera_matrix is not None else None\n        }\n\nclass StereoCameraSystem:\n    """\n    Integrate stereo camera system for depth perception\n    """\n    def __init__(self, left_camera_id=0, right_camera_id=1):\n        self.left_camera = CameraSystem(left_camera_id)\n        self.right_camera = CameraSystem(right_camera_id)\n        self.stereo_calib_data = None\n        self.rectification_maps = None\n\n    def calibrate_stereo_system(self, left_images, right_images):\n        """\n        Calibrate stereo camera system\n        """\n        # This would implement stereo calibration using corresponding points\n        # For simplicity, we\'ll simulate the process\n        print("Performing stereo calibration...")\n\n        # Calibrate individual cameras first\n        self.left_camera.calibrate_camera(left_images)\n        self.right_camera.calibrate_camera(right_images)\n\n        # In real implementation, you would:\n        # 1. Find corresponding points in both images\n        # 2. Use cv2.stereoCalibrate() to get rotation and translation\n        # 3. Use cv2.stereoRectify() to get rectification parameters\n\n        # Simulated stereo parameters\n        self.stereo_calib_data = {\n            \'rotation\': np.eye(3),  # Identity (cameras parallel)\n            \'translation\': np.array([-0.1, 0, 0]),  # 10cm baseline\n            \'essential_matrix\': np.array([[0, 0, 0], [0, 0, -0.1], [0, 0.1, 0]]),\n            \'fundamental_matrix\': np.array([[0, 0, 0], [0, 0, -1], [0, 1, 0]])\n        }\n\n        print("Stereo calibration complete")\n\n    def compute_depth_map(self, left_img, right_img):\n        """\n        Compute depth map from stereo pair\n        """\n        # Create stereo matcher\n        stereo = cv2.StereoSGBM_create(\n            minDisparity=0,\n            numDisparities=16*10,  # Must be divisible by 16\n            blockSize=5,\n            P1=8 * 3 * 5**2,\n            P2=32 * 3 * 5**2,\n            disp12MaxDiff=1,\n            uniquenessRatio=15,\n            speckleWindowSize=0,\n            speckleRange=2,\n            preFilterCap=63,\n            mode=cv2.STEREO_SGBM_MODE_SGBM_3WAY\n        )\n\n        # Compute disparity\n        gray_left = cv2.cvtColor(left_img, cv2.COLOR_BGR2GRAY)\n        gray_right = cv2.cvtColor(right_img, cv2.COLOR_BGR2GRAY)\n\n        disparity = stereo.compute(gray_left, gray_right).astype(np.float32) / 16.0\n\n        # Convert disparity to depth (simplified)\n        # Depth = (baseline * focal_length) / disparity\n        if self.left_camera.camera_matrix is not None:\n            baseline = 0.1  # 10cm baseline\n            focal_length = self.left_camera.camera_matrix[0, 0]\n            depth_map = (baseline * focal_length) / (disparity + 1e-6)  # Add small value to avoid division by zero\n        else:\n            depth_map = disparity  # Use disparity as proxy if no calibration\n\n        return depth_map\n\n    def get_stereo_frame(self):\n        """Get synchronized stereo frame pair"""\n        left_frame = self.left_camera.get_frame()\n        right_frame = self.right_camera.get_frame()\n        return left_frame, right_frame\n\n# Example usage\ndef camera_example():\n    # Initialize single camera\n    camera = CameraSystem(0)\n    camera.initialize_camera()\n\n    # Get frame and process\n    frame = camera.get_frame()\n    undistorted = camera.undistort_image(frame)\n\n    # For stereo, you would do:\n    # stereo_system = StereoCameraSystem(0, 1)  # Left and right camera IDs\n    # stereo_system.calibrate_stereo_system(left_calib_images, right_calib_images)\n    # left_img, right_img = stereo_system.get_stereo_frame()\n    # depth_map = stereo_system.compute_depth_map(left_img, right_img)\n\n    print("Camera system initialized and ready")\n    camera.cap.release()\n\n# Run example (commented out to avoid camera access issues)\n# camera_example()\n')),(0,a.yg)("h2",{id:"actuator-integration"},"Actuator Integration"),(0,a.yg)("h3",{id:"servo-motor-control"},"Servo Motor Control"),(0,a.yg)("p",null,"Servo motors are common in robotics for precise position control:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'import time\nimport threading\n\nclass ServoController:\n    """\n    Control servo motors with position, speed, and torque control\n    """\n    def __init__(self, pwm_frequency=50):  # 50Hz for standard servos\n        self.pwm_frequency = pwm_frequency\n        self.servos = {}\n        self.running = False\n        self.control_thread = None\n\n    def add_servo(self, servo_id, pin, min_pulse=500, max_pulse=2500,\n                  min_angle=-90, max_angle=90):\n        """\n        Add a servo motor to the controller\n        """\n        self.servos[servo_id] = {\n            \'pin\': pin,\n            \'min_pulse\': min_pulse,  # microseconds\n            \'max_pulse\': max_pulse,\n            \'min_angle\': min_angle,\n            \'max_angle\': max_angle,\n            \'current_angle\': 0,\n            \'target_angle\': 0,\n            \'speed_limit\': None,  # degrees per second\n            \'torque_limit\': None,  # percentage (0-100)\n            \'enabled\': True\n        }\n\n        # Initialize servo to center position\n        self.set_angle(servo_id, 0)\n        print(f"Added servo {servo_id} on pin {pin}")\n\n    def angle_to_pulse(self, servo_id, angle):\n        """Convert angle to PWM pulse width"""\n        servo = self.servos[servo_id]\n\n        # Clamp angle to valid range\n        angle = max(servo[\'min_angle\'], min(servo[\'max_angle\'], angle))\n\n        # Convert angle to pulse width\n        pulse_range = servo[\'max_pulse\'] - servo[\'min_pulse\']\n        angle_range = servo[\'max_angle\'] - servo[\'min_angle\']\n\n        pulse = servo[\'min_pulse\'] + (angle - servo[\'min_angle\']) * \\\n                (pulse_range / angle_range)\n\n        return int(pulse)\n\n    def set_angle(self, servo_id, angle, blocking=False):\n        """Set servo to specific angle"""\n        if servo_id not in self.servos:\n            raise ValueError(f"Servo {servo_id} not found")\n\n        servo = self.servos[servo_id]\n        servo[\'target_angle\'] = max(servo[\'min_angle\'], min(servo[\'max_angle\'], angle))\n\n        if blocking:\n            # Wait until servo reaches target (simplified)\n            while abs(servo[\'current_angle\'] - servo[\'target_angle\']) > 0.5:\n                time.sleep(0.01)\n\n    def set_speed_limit(self, servo_id, speed_dps):\n        """Set maximum speed for servo movement (degrees per second)"""\n        if servo_id in self.servos:\n            self.servos[servo_id][\'speed_limit\'] = speed_dps\n\n    def set_torque_limit(self, servo_id, torque_percent):\n        """Set torque limit as percentage"""\n        if servo_id in self.servos:\n            self.servos[servo_id][\'torque_limit\'] = max(0, min(100, torque_percent))\n\n    def enable_servo(self, servo_id, enabled=True):\n        """Enable or disable servo"""\n        if servo_id in self.servos:\n            self.servos[servo_id][\'enabled\'] = enabled\n\n    def get_position(self, servo_id):\n        """Get current servo position"""\n        if servo_id in self.servos:\n            return self.servos[servo_id][\'current_angle\']\n        return None\n\n    def start_control_loop(self):\n        """Start the control loop in a separate thread"""\n        if self.running:\n            return\n\n        self.running = True\n        self.control_thread = threading.Thread(target=self._control_loop)\n        self.control_thread.daemon = True\n        self.control_thread.start()\n\n    def stop_control_loop(self):\n        """Stop the control loop"""\n        self.running = False\n        if self.control_thread:\n            self.control_thread.join()\n\n    def _control_loop(self):\n        """Internal control loop"""\n        while self.running:\n            current_time = time.time()\n\n            for servo_id, servo in self.servos.items():\n                if not servo[\'enabled\']:\n                    continue\n\n                # Calculate how much to move based on speed limit\n                if servo[\'speed_limit\']:\n                    max_move = servo[\'speed_limit\'] * 0.02  # 20ms time step\n                    angle_diff = servo[\'target_angle\'] - servo[\'current_angle\']\n\n                    if abs(angle_diff) > max_move:\n                        # Move by maximum allowed amount\n                        direction = 1 if angle_diff > 0 else -1\n                        servo[\'current_angle\'] += direction * max_move\n                    else:\n                        servo[\'current_angle\'] = servo[\'target_angle\']\n                else:\n                    # Move directly to target\n                    servo[\'current_angle\'] = servo[\'target_angle\']\n\n                # Convert to PWM and send (in real implementation)\n                pulse_width = self.angle_to_pulse(servo_id, servo[\'current_angle\'])\n                # self._send_pwm_signal(servo[\'pin\'], pulse_width)\n\n            time.sleep(0.02)  # 50Hz update rate\n\n    def _send_pwm_signal(self, pin, pulse_width):\n        """Send PWM signal to servo (implementation depends on hardware)"""\n        # This would interface with actual hardware\n        # For example: GPIO on Raspberry Pi, PCA9685 servo driver, etc.\n        pass\n\nclass RobotArmController:\n    """\n    Control a multi-joint robot arm using servo controllers\n    """\n    def __init__(self):\n        self.servo_controller = ServoController()\n        self.joints = {}\n        self.dh_parameters = {}  # Denavit-Hartenberg parameters\n\n    def add_joint(self, joint_name, servo_id, pin, joint_type=\'revolute\',\n                  dh_params=None):\n        """\n        Add a joint to the robot arm\n        dh_params: [a, alpha, d, theta_offset] for DH parameters\n        """\n        self.servo_controller.add_servo(servo_id, pin)\n        self.joints[joint_name] = {\n            \'servo_id\': servo_id,\n            \'type\': joint_type,\n            \'dh_params\': dh_params or [0, 0, 0, 0]  # Default DH params\n        }\n\n    def move_to_joint_positions(self, joint_positions, duration=2.0, blocking=True):\n        """\n        Move all joints to specified positions over duration\n        joint_positions: dict like {\'joint1\': angle1, \'joint2\': angle2, ...}\n        """\n        # Calculate intermediate positions for smooth motion\n        start_positions = {name: self.servo_controller.get_position(\n            self.joints[name][\'servo_id\']) for name in joint_positions.keys()}\n\n        num_steps = int(duration * 50)  # 50Hz control rate\n        for step in range(num_steps + 1):\n            t = step / num_steps  # Normalized time [0, 1]\n\n            # Interpolate to target position\n            for joint_name, target_pos in joint_positions.items():\n                start_pos = start_positions[joint_name]\n                current_pos = start_pos + t * (target_pos - start_pos)\n\n                servo_id = self.joints[joint_name][\'servo_id\']\n                self.servo_controller.set_angle(servo_id, current_pos)\n\n            time.sleep(0.02)  # 50Hz rate\n\n    def move_to_cartesian(self, target_position, target_orientation=None):\n        """\n        Move end effector to Cartesian position using inverse kinematics\n        """\n        # This would implement inverse kinematics\n        # For a simple 2-DOF arm:\n        x, y, z = target_position\n\n        # Calculate joint angles (simplified 2D example)\n        r = (x**2 + y**2)**0.5\n        # ... more complex IK calculations\n\n        # For now, just a placeholder\n        print(f"Moving to Cartesian position: {target_position}")\n\n    def get_joint_positions(self):\n        """Get current joint positions"""\n        positions = {}\n        for joint_name, joint_info in self.joints.items():\n            pos = self.servo_controller.get_position(joint_info[\'servo_id\'])\n            positions[joint_name] = pos\n        return positions\n\n# Example usage\ndef servo_example():\n    arm = RobotArmController()\n\n    # Add joints (simplified example)\n    arm.add_joint(\'shoulder\', servo_id=1, pin=11, dh_params=[0.1, 0, 0, 0])\n    arm.add_joint(\'elbow\', servo_id=2, pin=12, dh_params=[0.1, 0, 0, 0])\n    arm.add_joint(\'wrist\', servo_id=3, pin=13, dh_params=[0.05, 0, 0, 0])\n\n    # Start servo control\n    arm.servo_controller.start_control_loop()\n\n    # Move to positions\n    positions = {\'shoulder\': 30, \'elbow\': -45, \'wrist\': 15}\n    arm.move_to_joint_positions(positions, duration=2.0)\n\n    print("Current joint positions:", arm.get_joint_positions())\n\n    # Stop control\n    arm.servo_controller.stop_control_loop()\n\n# Run example (commented out to avoid hardware dependencies)\n# servo_example()\n')),(0,a.yg)("h3",{id:"motor-control-with-feedback"},"Motor Control with Feedback"),(0,a.yg)("p",null,"DC motors with encoders provide velocity and position feedback:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'class DCMotorController:\n    """\n    Control DC motors with encoder feedback\n    """\n    def __init__(self, motor_id, encoder_resolution=1000):\n        self.motor_id = motor_id\n        self.encoder_resolution = encoder_resolution  # counts per revolution\n        self.current_position = 0\n        self.current_velocity = 0\n        self.target_position = 0\n        self.target_velocity = 0\n        self.max_pwm = 255\n        self.pwm_output = 0\n\n        # PID controller parameters\n        self.pid = {\n            \'position\': {\'kp\': 10.0, \'ki\': 0.1, \'kd\': 0.5},\n            \'velocity\': {\'kp\': 2.0, \'ki\': 0.05, \'kd\': 0.1}\n        }\n\n        self.integral_errors = {\'position\': 0, \'velocity\': 0}\n        self.previous_errors = {\'position\': 0, \'velocity\': 0}\n        self.control_rate = 100  # Hz\n        self.dt = 1.0 / self.control_rate\n\n    def update_encoder(self, encoder_count):\n        """Update position based on encoder count"""\n        # Calculate position in radians\n        self.current_position = (encoder_count / self.encoder_resolution) * 2 * 3.14159\n\n        # Calculate velocity (simplified)\n        # In real implementation, this would use time-based differentiation\n\n    def pid_control(self, error, mode=\'position\'):\n        """Apply PID control"""\n        pid_params = self.pid[mode]\n\n        # Update integral\n        self.integral_errors[mode] += error * self.dt\n        # Apply integral windup protection\n        self.integral_errors[mode] = max(-10, min(10, self.integral_errors[mode]))\n\n        # Calculate derivative\n        derivative = (error - self.previous_errors[mode]) / self.dt\n\n        # Apply PID formula\n        output = (pid_params[\'kp\'] * error +\n                 pid_params[\'ki\'] * self.integral_errors[mode] +\n                 pid_params[\'kd\'] * derivative)\n\n        # Store current error for next derivative calculation\n        self.previous_errors[mode] = error\n\n        return output\n\n    def control_position(self, target_position):\n        """Control motor position using PID"""\n        position_error = target_position - self.current_position\n        pwm_output = self.pid_control(position_error, \'position\')\n\n        # Limit PWM output\n        self.pwm_output = max(-self.max_pwm, min(self.max_pwm, int(pwm_output)))\n\n        # Send PWM command (in real implementation)\n        # self._send_pwm_command(self.pwm_output)\n\n        return self.pwm_output\n\n    def control_velocity(self, target_velocity):\n        """Control motor velocity using PID"""\n        velocity_error = target_velocity - self.current_velocity\n        pwm_output = self.pid_control(velocity_error, \'velocity\')\n\n        # Limit PWM output\n        self.pwm_output = max(-self.max_pwm, min(self.max_pwm, int(pwm_output)))\n\n        # Send PWM command (in real implementation)\n        # self._send_pwm_command(self.pwm_output)\n\n        return self.pwm_output\n\n    def enable_motor(self, enabled=True):\n        """Enable or disable motor"""\n        # In real implementation, this would control H-bridge enable pin\n        pass\n\nclass MotorControlSystem:\n    """\n    Manage multiple DC motors with coordinated control\n    """\n    def __init__(self):\n        self.motors = {}\n        self.control_thread = None\n        self.running = False\n\n    def add_motor(self, motor_name, motor_id, encoder_resolution=1000):\n        """Add a DC motor to the system"""\n        self.motors[motor_name] = DCMotorController(motor_id, encoder_resolution)\n        print(f"Added motor {motor_name} with ID {motor_id}")\n\n    def start_control(self):\n        """Start the control loop"""\n        self.running = True\n        self.control_thread = threading.Thread(target=self._control_loop)\n        self.control_thread.daemon = True\n        self.control_thread.start()\n\n    def stop_control(self):\n        """Stop the control loop"""\n        self.running = False\n        if self.control_thread:\n            self.control_thread.join()\n\n    def _control_loop(self):\n        """Main control loop"""\n        import time\n\n        while self.running:\n            start_time = time.time()\n\n            # Update all motors\n            for motor_name, motor in self.motors.items():\n                # For position control, call motor.control_position(target_pos)\n                # For velocity control, call motor.control_velocity(target_vel)\n                pass\n\n            # Maintain control rate\n            elapsed = time.time() - start_time\n            sleep_time = max(0, (1.0 / 100) - elapsed)  # 100Hz rate\n            if sleep_time > 0:\n                time.sleep(sleep_time)\n\n    def move_motors_sync(self, motor_positions, duration=2.0):\n        """\n        Move multiple motors synchronously to target positions\n        """\n        start_positions = {name: motor.current_position\n                          for name, motor in self.motors.items()}\n\n        num_steps = int(duration * self.motors[list(self.motors.keys())[0]].control_rate)\n\n        for step in range(num_steps + 1):\n            t = step / num_steps  # Normalized time [0, 1]\n\n            for motor_name, target_pos in motor_positions.items():\n                if motor_name in self.motors:\n                    start_pos = start_positions[motor_name]\n                    current_target = start_pos + t * (target_pos - start_pos)\n                    self.motors[motor_name].control_position(current_target)\n\n            time.sleep(1.0 / 100)  # 100Hz rate\n\n# Example usage\ndef motor_example():\n    motor_system = MotorControlSystem()\n\n    # Add motors\n    motor_system.add_motor(\'left_wheel\', 1, encoder_resolution=2000)\n    motor_system.add_motor(\'right_wheel\', 2, encoder_resolution=2000)\n\n    # Start control system\n    motor_system.start_control()\n\n    # Move motors to positions\n    positions = {\'left_wheel\': 1.57, \'right_wheel\': 1.57}  # 90 degrees each\n    motor_system.move_motors_sync(positions, duration=2.0)\n\n    # Stop control\n    motor_system.stop_control()\n\n# Run example (commented out to avoid hardware dependencies)\n# motor_example()\n')),(0,a.yg)("h2",{id:"software-integration"},"Software Integration"),(0,a.yg)("h3",{id:"real-time-control-considerations"},"Real-time Control Considerations"),(0,a.yg)("p",null,"Real-time performance is crucial for physical AI systems:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'import time\nimport threading\nimport queue\nfrom collections import deque\n\nclass RealTimeController:\n    """\n    Real-time control system with timing guarantees\n    """\n    def __init__(self, control_frequency=1000):  # Hz\n        self.control_frequency = control_frequency\n        self.dt = 1.0 / control_frequency\n        self.running = False\n        self.control_thread = None\n        self.sensors = {}\n        self.actuators = {}\n        self.control_law = None\n        self.timing_stats = deque(maxlen=100)  # Keep last 100 timing samples\n\n    def add_sensor(self, name, callback, frequency=None):\n        """Add sensor with optional specific frequency"""\n        self.sensors[name] = {\n            \'callback\': callback,\n            \'frequency\': frequency or self.control_frequency,\n            \'last_update\': 0,\n            \'data\': None\n        }\n\n    def add_actuator(self, name, callback):\n        """Add actuator"""\n        self.actuators[name] = {\n            \'callback\': callback,\n            \'last_command\': None\n        }\n\n    def set_control_law(self, control_function):\n        """Set the control law function"""\n        self.control_law = control_function\n\n    def start(self):\n        """Start real-time control loop"""\n        if self.running:\n            return\n\n        self.running = True\n        self.control_thread = threading.Thread(target=self._control_loop)\n        self.control_thread.daemon = True\n        self.control_thread.start()\n\n    def stop(self):\n        """Stop real-time control loop"""\n        self.running = False\n        if self.control_thread:\n            self.control_thread.join()\n\n    def _control_loop(self):\n        """Main real-time control loop"""\n        next_update = time.time()\n\n        while self.running:\n            loop_start = time.time()\n\n            # Read sensors\n            sensor_data = {}\n            for name, sensor in self.sensors.items():\n                if loop_start - sensor[\'last_update\'] >= 1.0 / sensor[\'frequency\']:\n                    sensor[\'data\'] = sensor[\'callback\']()\n                    sensor[\'last_update\'] = loop_start\n                sensor_data[name] = sensor[\'data\']\n\n            # Execute control law\n            if self.control_law:\n                commands = self.control_law(sensor_data)\n            else:\n                commands = {}\n\n            # Send commands to actuators\n            for name, command in commands.items():\n                if name in self.actuators:\n                    self.actuators[name][\'callback\'](command)\n                    self.actuators[name][\'last_command\'] = command\n\n            # Calculate timing\n            loop_end = time.time()\n            loop_time = loop_end - loop_start\n            self.timing_stats.append({\n                \'loop_time\': loop_time,\n                \'deadline_miss\': loop_time > self.dt,\n                \'slack_time\': self.dt - loop_time\n            })\n\n            # Sleep to maintain frequency\n            next_update += self.dt\n            sleep_time = next_update - time.time()\n            if sleep_time > 0:\n                time.sleep(sleep_time)\n            else:\n                # Deadline miss - log for analysis\n                print(f"Deadline miss: {abs(sleep_time)*1000:.2f}ms late")\n\n    def get_timing_analysis(self):\n        """Get timing performance analysis"""\n        if not self.timing_stats:\n            return "No timing data available"\n\n        loop_times = [s[\'loop_time\'] for s in self.timing_stats]\n        avg_time = sum(loop_times) / len(loop_times)\n        max_time = max(loop_times)\n        deadline_misses = sum(1 for s in self.timing_stats if s[\'deadline_miss\'])\n\n        return {\n            \'average_loop_time_ms\': avg_time * 1000,\n            \'max_loop_time_ms\': max_time * 1000,\n            \'deadline_misses\': deadline_misses,\n            \'miss_rate_percent\': (deadline_misses / len(self.timing_stats)) * 100\n        }\n\nclass SensorEmulator:\n    """Emulate sensor data for testing"""\n    def __init__(self, base_value=0, noise_level=0.01):\n        self.base_value = base_value\n        self.noise_level = noise_level\n        self.time = 0\n\n    def read(self):\n        """Simulate sensor reading with noise"""\n        import random\n        self.time += 0.001  # Simulate time passing\n        return self.base_value + random.gauss(0, self.noise_level) + 0.1 * math.sin(2 * math.pi * 2 * self.time)\n\nclass ActuatorEmulator:\n    """Emulate actuator for testing"""\n    def __init__(self):\n        self.current_value = 0\n\n    def command(self, value):\n        """Simulate sending command to actuator"""\n        self.current_value = value\n        # In real implementation, this would send signal to hardware\n\n# Example usage\ndef real_time_example():\n    import math\n\n    controller = RealTimeController(control_frequency=100)  # 100 Hz\n\n    # Add emulated sensors\n    position_sensor = SensorEmulator(base_value=0, noise_level=0.01)\n    velocity_sensor = SensorEmulator(base_value=0, noise_level=0.005)\n\n    controller.add_sensor(\'position\', position_sensor.read, frequency=100)\n    controller.add_sensor(\'velocity\', velocity_sensor.read, frequency=100)\n\n    # Add emulated actuators\n    motor = ActuatorEmulator()\n    controller.add_actuator(\'motor\', motor.command)\n\n    # Define simple PD controller\n    def simple_pd_control(sensor_data):\n        position = sensor_data[\'position\'] or 0\n        velocity = sensor_data[\'velocity\'] or 0\n\n        # Simple PD controller to maintain position at 0\n        kp = 10.0\n        kd = 2.0\n        target_position = 0\n\n        error = target_position - position\n        control_output = kp * error - kd * velocity\n\n        return {\'motor\': max(-100, min(100, control_output))}  # Limit to \xb1100\n\n    controller.set_control_law(simple_pd_control)\n\n    # Start control\n    controller.start()\n\n    # Run for 5 seconds\n    time.sleep(5)\n\n    # Get timing analysis\n    timing_info = controller.get_timing_analysis()\n    print("Timing Analysis:", timing_info)\n\n    # Stop control\n    controller.stop()\n\n# Run example\n# real_time_example()\n')),(0,a.yg)("h2",{id:"safety-and-fault-handling"},"Safety and Fault Handling"),(0,a.yg)("h3",{id:"safety-system-implementation"},"Safety System Implementation"),(0,a.yg)("p",null,"Safety is paramount in physical AI systems:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},"class SafetySystem:\n    \"\"\"\n    Comprehensive safety system for physical AI\n    \"\"\"\n    def __init__(self):\n        self.emergency_stop = False\n        self.faults = {}\n        self.safety_limits = {}\n        self.protection_systems = []\n        self.shutdown_sequence = []\n        self.monitoring_enabled = True\n\n    def add_current_monitor(self, motor_name, max_current):\n        \"\"\"Monitor motor current for overcurrent protection\"\"\"\n        self.safety_limits[f'{motor_name}_current'] = max_current\n\n    def add_temperature_monitor(self, component_name, max_temp):\n        \"\"\"Monitor component temperature\"\"\"\n        self.safety_limits[f'{component_name}_temp'] = max_temp\n\n    def add_position_limit(self, joint_name, min_pos, max_pos):\n        \"\"\"Set position limits for joints\"\"\"\n        self.safety_limits[f'{joint_name}_min'] = min_pos\n        self.safety_limits[f'{joint_name}_max'] = max_pos\n\n    def add_velocity_limit(self, component_name, max_vel):\n        \"\"\"Set velocity limits\"\"\"\n        self.safety_limits[f'{component_name}_vel'] = max_vel\n\n    def check_safety(self, sensor_data):\n        \"\"\"\n        Check all safety conditions\n        Returns: (is_safe, list_of_violations)\n        \"\"\"\n        violations = []\n\n        # Check current limits\n        for key, value in sensor_data.items():\n            if key.endswith('_current'):\n                motor_name = key.replace('_current', '')\n                limit_key = f'{motor_name}_current'\n                if limit_key in self.safety_limits:\n                    if value > self.safety_limits[limit_key]:\n                        violations.append(f\"Overcurrent on {motor_name}: {value}A > {self.safety_limits[limit_key]}A\")\n\n        # Check temperature limits\n        for key, value in sensor_data.items():\n            if key.endswith('_temp'):\n                component_name = key.replace('_temp', '')\n                limit_key = f'{component_name}_temp'\n                if limit_key in self.safety_limits:\n                    if value > self.safety_limits[limit_key]:\n                        violations.append(f\"Overtemperature on {component_name}: {value}\xb0C > {self.safety_limits[limit_key]}\xb0C\")\n\n        # Check position limits\n        for key, value in sensor_data.items():\n            if key.endswith('_position'):\n                joint_name = key.replace('_position', '')\n                min_key = f'{joint_name}_min'\n                max_key = f'{joint_name}_max'\n                if min_key in self.safety_limits and max_key in self.safety_limits:\n                    if value < self.safety_limits[min_key] or value > self.safety_limits[max_key]:\n                        violations.append(f\"Position limit violation on {joint_name}: {value} rad\")\n\n        # Check velocity limits\n        for key, value in sensor_data.items():\n            if key.endswith('_velocity'):\n                component_name = key.replace('_velocity', '')\n                limit_key = f'{component_name}_vel'\n                if limit_key in self.safety_limits:\n                    if abs(value) > self.safety_limits[limit_key]:\n                        violations.append(f\"Velocity limit violation on {component_name}: {abs(value)} rad/s > {self.safety_limits[limit_key]} rad/s\")\n\n        return len(violations) == 0, violations\n\n    def emergency_stop(self):\n        \"\"\"Activate emergency stop\"\"\"\n        print(\"EMERGENCY STOP ACTIVATED!\")\n        self.emergency_stop = True\n        # In real implementation, this would:\n        # - Cut power to all motors\n        # - Apply brakes if available\n        # - Execute shutdown sequence\n\n    def fault_detected(self, fault_type, severity='medium'):\n        \"\"\"Handle fault detection\"\"\"\n        self.faults[fault_type] = {\n            'time': time.time(),\n            'severity': severity,\n            'handled': False\n        }\n\n        if severity == 'high':\n            self.emergency_stop()\n        elif severity == 'medium':\n            print(f\"Medium severity fault detected: {fault_type}\")\n        else:\n            print(f\"Low severity fault detected: {fault_type}\")\n\n    def get_safety_status(self):\n        \"\"\"Get current safety status\"\"\"\n        return {\n            'emergency_stop': self.emergency_stop,\n            'faults': self.faults,\n            'safety_limits': self.safety_limits\n        }\n\nclass HardwareSafetyManager:\n    \"\"\"\n    Manage safety for hardware components\n    \"\"\"\n    def __init__(self):\n        self.safety_system = SafetySystem()\n        self.watchdog_timers = {}\n        self.hardware_interfaces = []\n\n    def add_watchdog(self, name, timeout=2.0):\n        \"\"\"Add watchdog timer for critical components\"\"\"\n        self.watchdog_timers[name] = {\n            'timeout': timeout,\n            'last_update': time.time(),\n            'enabled': True\n        }\n\n    def feed_watchdog(self, name):\n        \"\"\"Reset watchdog timer\"\"\"\n        if name in self.watchdog_timers:\n            self.watchdog_timers[name]['last_update'] = time.time()\n\n    def check_watchdogs(self):\n        \"\"\"Check if any watchdogs have timed out\"\"\"\n        current_time = time.time()\n        timeouts = []\n\n        for name, timer in self.watchdog_timers.items():\n            if timer['enabled'] and (current_time - timer['last_update']) > timer['timeout']:\n                timeouts.append(name)\n                print(f\"Watchdog timeout: {name}\")\n                self.safety_system.fault_detected(f'watchdog_timeout_{name}', 'high')\n\n        return timeouts\n\n    def monitor_system(self, sensor_data):\n        \"\"\"\n        Monitor entire system for safety violations\n        \"\"\"\n        # Check safety conditions\n        is_safe, violations = self.safety_system.check_safety(sensor_data)\n\n        if not is_safe:\n            for violation in violations:\n                print(f\"Safety violation: {violation}\")\n                self.safety_system.fault_detected(violation, 'medium')\n\n        # Check watchdogs\n        self.check_watchdogs()\n\n        return is_safe\n\n# Example usage\ndef safety_example():\n    safety_manager = HardwareSafetyManager()\n\n    # Set up safety limits\n    safety_manager.safety_system.add_current_monitor('left_motor', 10.0)  # 10A limit\n    safety_manager.safety_system.add_current_monitor('right_motor', 10.0)\n    safety_manager.safety_system.add_temperature_monitor('controller', 80)  # 80\xb0C limit\n    safety_manager.safety_system.add_position_limit('hip_joint', -1.57, 1.57)  # \xb190\xb0\n    safety_manager.safety_system.add_velocity_limit('wheel', 5.0)  # 5 rad/s limit\n\n    # Add watchdog for critical systems\n    safety_manager.add_watchdog('motion_control', timeout=1.0)\n    safety_manager.add_watchdog('safety_monitor', timeout=0.5)\n\n    # Simulate sensor data\n    sensor_data = {\n        'left_motor_current': 8.5,\n        'right_motor_current': 9.2,\n        'controller_temp': 65,\n        'hip_joint_position': 0.5,\n        'wheel_velocity': 3.2\n    }\n\n    # Monitor system\n    is_safe = safety_manager.monitor_system(sensor_data)\n    print(f\"System safety status: {'SAFE' if is_safe else 'UNSAFE'}\")\n\n    # Feed watchdogs\n    safety_manager.feed_watchdog('motion_control')\n    safety_manager.feed_watchdog('safety_monitor')\n\n    print(\"Safety system operational\")\n\n# Run example\nsafety_example()\n")),(0,a.yg)("h2",{id:"troubleshooting-and-debugging"},"Troubleshooting and Debugging"),(0,a.yg)("h3",{id:"common-hardware-integration-issues"},"Common Hardware Integration Issues"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},"class HardwareDiagnostics:\n    \"\"\"\n    Diagnostic tools for hardware integration issues\n    \"\"\"\n    def __init__(self):\n        self.diagnostics = []\n        self.known_issues = {\n            'communication_timeout': {\n                'symptoms': ['No response from device', 'Intermittent data'],\n                'causes': ['Loose connections', 'Wrong baud rate', 'Noise interference'],\n                'solutions': ['Check connections', 'Verify baud rate', 'Use shielded cables']\n            },\n            'power_instability': {\n                'symptoms': ['Random resets', 'Inconsistent behavior', 'Overheating'],\n                'causes': ['Insufficient power supply', 'Voltage drops', 'Poor grounding'],\n                'solutions': ['Check power ratings', 'Add capacitors', 'Verify ground connections']\n            },\n            'calibration_drift': {\n                'symptoms': ['Inaccurate readings', 'Drifting values', 'Poor performance'],\n                'causes': ['Temperature changes', 'Mechanical stress', 'Component aging'],\n                'solutions': ['Re-calibrate', 'Temperature compensation', 'Replace components']\n            }\n        }\n\n    def run_power_diagnosis(self, voltage_readings, current_readings):\n        \"\"\"Diagnose power-related issues\"\"\"\n        issues = []\n\n        # Check for voltage drops\n        for i, voltage in enumerate(voltage_readings):\n            if voltage < 0.9 * self.get_expected_voltage():\n                issues.append(f\"Voltage drop detected at reading {i}: {voltage}V\")\n\n        # Check for current spikes\n        avg_current = sum(current_readings) / len(current_readings)\n        for i, current in enumerate(current_readings):\n            if current > 1.5 * avg_current:\n                issues.append(f\"Current spike detected at reading {i}: {current}A\")\n\n        return issues\n\n    def run_communication_diagnosis(self, device_responses, expected_responses):\n        \"\"\"Diagnose communication issues\"\"\"\n        issues = []\n\n        for device, response in device_responses.items():\n            expected = expected_responses.get(device)\n            if response != expected:\n                issues.append(f\"Communication error with {device}: got {response}, expected {expected}\")\n\n        return issues\n\n    def get_expected_voltage(self):\n        \"\"\"Get expected system voltage\"\"\"\n        # This would be configured based on system design\n        return 12.0  # Example: 12V system\n\n    def generate_diagnostic_report(self, test_results):\n        \"\"\"Generate comprehensive diagnostic report\"\"\"\n        report = {\n            'timestamp': time.time(),\n            'system_health': 'good',\n            'issues_found': [],\n            'recommendations': [],\n            'test_results': test_results\n        }\n\n        # Analyze results and add to report\n        for test_name, results in test_results.items():\n            if results.get('status') == 'fail':\n                report['issues_found'].append({\n                    'test': test_name,\n                    'details': results.get('details', ''),\n                    'severity': results.get('severity', 'medium')\n                })\n\n        # Determine overall health\n        if report['issues_found']:\n            report['system_health'] = 'degraded'\n            if any(issue['severity'] == 'high' for issue in report['issues_found']):\n                report['system_health'] = 'critical'\n\n        return report\n\n# Example diagnostic usage\ndef run_hardware_diagnostics():\n    diagnostics = HardwareDiagnostics()\n\n    # Simulate test results\n    test_results = {\n        'power_test': {\n            'status': 'pass',\n            'details': 'All voltages within acceptable range',\n            'severity': 'low'\n        },\n        'communication_test': {\n            'status': 'fail',\n            'details': 'Device at address 0x42 not responding',\n            'severity': 'high'\n        },\n        'sensor_test': {\n            'status': 'pass',\n            'details': 'All sensors responding correctly',\n            'severity': 'low'\n        }\n    }\n\n    report = diagnostics.generate_diagnostic_report(test_results)\n    print(\"Diagnostic Report:\")\n    print(f\"System Health: {report['system_health']}\")\n    print(f\"Issues Found: {len(report['issues_found'])}\")\n    for issue in report['issues_found']:\n        print(f\"  - {issue['test']}: {issue['details']} (Severity: {issue['severity']})\")\n\n# Run diagnostic example\nrun_hardware_diagnostics()\n")),(0,a.yg)("h2",{id:"learning-objectives"},"Learning Objectives"),(0,a.yg)("p",null,"After completing this tutorial, you should be able to:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"Design mechanical systems with proper integration considerations"),(0,a.yg)("li",{parentName:"ol"},"Implement power distribution systems for robotic applications"),(0,a.yg)("li",{parentName:"ol"},"Integrate various sensors (IMU, cameras, encoders) with proper calibration"),(0,a.yg)("li",{parentName:"ol"},"Control different types of actuators (servos, DC motors) with feedback"),(0,a.yg)("li",{parentName:"ol"},"Implement real-time control systems with timing guarantees"),(0,a.yg)("li",{parentName:"ol"},"Design safety systems and fault handling mechanisms"),(0,a.yg)("li",{parentName:"ol"},"Troubleshoot common hardware integration issues")),(0,a.yg)("h2",{id:"hands-on-exercise"},"Hands-On Exercise"),(0,a.yg)("p",null,"Design and implement a complete hardware integration for a simple robot:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"Design the mechanical structure using appropriate materials"),(0,a.yg)("li",{parentName:"ol"},"Create a power distribution system for your robot's components"),(0,a.yg)("li",{parentName:"ol"},"Integrate at least 3 different types of sensors (IMU, camera, encoders)"),(0,a.yg)("li",{parentName:"ol"},"Implement control for 2-3 actuators with feedback"),(0,a.yg)("li",{parentName:"ol"},"Create a safety system with emergency stops and fault detection"),(0,a.yg)("li",{parentName:"ol"},"Test your integration with a simple task (e.g., move to a position, avoid obstacles)"),(0,a.yg)("li",{parentName:"ol"},"Document any issues encountered and how you resolved them")),(0,a.yg)("p",null,"This exercise will give you practical experience with the challenges and solutions involved in physical AI hardware integration."))}_.isMDXComponent=!0}}]);